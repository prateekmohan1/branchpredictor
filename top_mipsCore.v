//
//--------------------------------------------------------------------------------
//          THIS FILE WAS AUTOMATICALLY GENERATED BY THE GENESIS2 ENGINE        
//  FOR MORE INFORMATION: OFER SHACHAM (CHIP GENESIS INC / STANFORD VLSI GROUP)
//    !! THIS VERSION OF GENESIS2 IS NOT FOR ANY COMMERCIAL USE !!
//     FOR COMMERCIAL LICENSE CONTACT SHACHAM@ALUMNI.STANFORD.EDU
//--------------------------------------------------------------------------------
//
//  
//	-----------------------------------------------
//	|            Genesis Release Info             |
//	|  $Change: 11904 $ --- $Date: 2013/08/03 $   |
//	-----------------------------------------------
//	
//
//  Source file: /afs/asu.edu/users/p/m/o/pmohan6/EEE591Brunhav/ProjPart4/Submission/primitives/top_mipsCore.vp
//  Source template: top_mipsCore
//
// --------------- Begin Pre-Generation Parameters Status Report ---------------
//
//	From 'generate' statement (priority=5):
//
//		---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----
//
//	From Command Line input (priority=4):
//
//		---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----
//
//	From XML input (priority=3):
//
//		---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----
//
//	From Config File input (priority=2):
//
// ---------------- End Pre-Generation Pramameters Status Report ----------------

/////////////
// top_seqDiv.vp

`include "mipsCore.v"
`include "seqMult.v"
`include "seqDiv.v"
`include "alu.v"
`include "dff.v"
`include "dffbW_unq1.v"
`include "dffbW_unq2.v"
`include "dffbW_unq3.v"
`include "dffbW_unq4.v"
`include "dffbW_unq5.v"
`include "dffbW_unq6.v"
`include "dffbW_unq7.v"
`include "bpredict.v"
`include "dCache.v"

// Top module without inputs or outputs
module top_mipsCore ();

  // To instantiate a module, first you have to 
  // generate the module and then instantiate it

  //ICache IFC
  logic [31:0] iCacheReadData;
  logic [31:0] iCacheReadData_f;
  logic [31:0] iCacheReadAddr;
  logic [31:0] previCacheReadData;
  
  //DCache Ifc
  logic [31:0] dCacheReadData;
  logic [31:0] dCacheWriteData;
  logic [31:0] dCacheAddr;
  logic dCacheWriteEn;
  logic dCacheReadEn;
  
  //Register File Ifc
  logic [31:0] rfReadData_p0;
  logic [4:0] rfReadAddr_p0;
  logic rfReadEn_p0;
  logic [31:0] rfReadData_p1;
  logic [4:0] rfReadAddr_p1;
  logic rfReadEn_p1;
  logic [31:0] rfWriteData_p0;
  logic [4:0] rfWriteAddr_p0;
  logic rfWriteEn_p0;

  //BTB Ifc
  
  //Globals
  logic clk;
  logic rst;
  logic start;
  logic stop;

  //Mem iCache
  logic [31:0] memiCache [479:0];
  logic [31:0] memdCache [479:0];
  logic [31:0] memrfCache [31:0];
  logic [31:0] instrCount ;

  logic in_ready, rdEn, wrEn, in_valid;
  logic triggerStart, triggerStop, foo;  
  logic toggle;

  int i;

  real IPC;

  logic [5:0]opcode;
  logic [5:0]special;
  logic [19:0]alu_op;
  logic [19:0]Cyc_count;
  logic [19:0]Instr_count;

  // Now we instantiate it
  mipsCore  my_mipsCore (
	.iCacheReadData(iCacheReadData),
	.iCacheReadAddr(iCacheReadAddr),
	.dCacheReadData(dCacheReadData),
	.dCacheWriteData(dCacheWriteData),
	.dCacheAddr(dCacheAddr),
	.dCacheWriteEn(dCacheWriteEn),
	.dCacheReadEn(dCacheReadEn),
	.rfReadData_p0(rfReadData_p0),
	.rfReadAddr_p0(rfReadAddr_p0),
	.rfReadEn_p0(rfReadEn_p0),
	.rfReadData_p1(rfReadData_p1),
	.rfReadAddr_p1(rfReadAddr_p1),
	.rfReadEn_p1(rfReadEn_p1),
	.rfWriteData_p0(rfWriteData_p0),
	.rfWriteAddr_p0(rfWriteAddr_p0),
	.rfWriteEn_p0(rfWriteEn_p0),
	.clk(clk),
	.rst(rst)
	);

  initial begin
    Cyc_count = 0;
    clk = 0;
    in_valid = 0;
    Instr_count = 0;
  end

  always begin
    #250 clk = ~clk;
  end

// ----- Start Include Of /afs/asu.edu/users/p/m/o/pmohan6/EEE591Brunhav/ProjPart4/Submission/primitives/taskHeader.vph -----
task init_mem (inout logic [31:0] iCache [479:0], inout logic [31:0] rfCache [31:0], inout logic rst);

	int i, j;
	int data_file;
	int scan_file;
	logic [31:0] captured_data;

	rst = 1;

	//Populate the I$
	data_file = $fopen("min_test","r");
		for (i = 0; i < 10000; i++) begin
		scan_file = $fscanf(data_file,"%h\n", captured_data);
		if ($feof(data_file)) begin
			instrCount = i;
			break;
		end
		j = i;
		iCache[j] = captured_data;
		$display("memiCache[%d] is %h",j,iCache[j]);
	end


	//Populate the RF
	for (i=0;i<32;i++) begin
		rfCache[i] = 32'b0;
	end

	//Initialize the stack pointer
	rfCache[29] = 477;

endtask

task resetMachine (inout logic rst);
    #230;
    rst = 1'b0;

    #500;
    rst = 1'b1;
endtask

task waitTime(inout logic [31:0] iCacheData, output logic toggle);

	if (iCacheData !== 32'bx) begin
		toggle = 1'b0;
	end
	else begin
		toggle = 1'b1;
	end	

endtask

task detectFailuretoComplete (inout logic [31:0] iCacheData);

	if (iCacheData === 32'bx) begin
		$display ("*************************************");
		$display ("*************************************");
		$display ("*************************************");
		$display ("*************************************");
		$display ("Test has completed going through I$");
		$display ("*************************************");
		$display ("*************************************");
		$display ("*************************************");
		$display ("*************************************");
	end
	else begin
		$display ("Test is stuck in some loop");
	end

endtask

task detectSuccess(inout logic [31:0] rfCache [31:0]);

	//if (rfCache[2] == 16) begin	//Max
	//if (rfCache[2] == 7) begin	//Mode
	//if (rfCache[2] == 9) begin	//1DConv
	if (rfCache[2] == 9) begin	//MatMult
		$display("Success! The test completed!");
		$display ("*************************************");
		$display ("*************************************");
		$display ("*************************************");
		$display ("*************************************");
	end
	else begin
		$display("Failure. The register value of R2 is incorrect.");
		$display ("*************************************");
		$display ("*************************************");
		$display ("*************************************");
		$display ("*************************************");
	end

endtask

task calcIPC (inout real ipc, inout [31:0] instrCount, inout [31:0] cycCount);

	$display ("cycCount is %d. instrCount is %d", cycCount, instrCount);

	ipc = cycCount/instrCount;
	ipc = 1/ipc;

endtask
// ----- End Include Of /afs/asu.edu/users/p/m/o/pmohan6/EEE591Brunhav/ProjPart4/Submission/primitives/taskHeader.vph -----

  initial begin
    toggle = 1'b0;
    triggerStart = 1'b0;
    triggerStop = 1'b0;
    start = 1'b0;
    rst = 1'b1;

    init_mem(memiCache, memrfCache, rst);
 
    #230;
    rst = 1'b0;
    triggerStart = 1'b1;

    #500;
    rst = 1'b1;
    start = 1'b1;

  end

  initial begin
    $dumpfile("dump.vcd");
    $dumpvars(0, top_mipsCore);
  end  

  always begin
    @(posedge clk) begin
      iCacheReadData_f <= iCacheReadData;
    end
  end

  always begin
    @(posedge clk) begin
      if (start & toggle == 1'b0) begin
	      waitTime(iCacheReadData, toggle);
      end
      if (start && iCacheReadData !== 32'bx) begin
        Cyc_count = Cyc_count + 1;
      end
      if (iCacheReadData_f != iCacheReadData) begin
	Instr_count = Instr_count + 1;
      end
    end
  end

  always begin
    @(posedge clk) begin

      if (toggle == 1'b1) begin
        detectFailuretoComplete(iCacheReadData);
  
        detectSuccess(memrfCache);
  
        calcIPC(IPC, Instr_count, Cyc_count);
  
        $display("IPC is %f", IPC);
  
        $finish();
      end

      //$display("current time is %0dns. previCacheReadData is %b.", $time, previCacheReadData);
    end
  end

  //initial begin
  //  if ($test$plusargs("wave")) begin
  //    $display("%t: Starting Wave Capture", $time);
  //    $vcdpluson(0, top_mipsCore);
  //    $vcdplusmemon(0, top_mipsCore);
  //  end
  //end

  //I$ instructions
  always begin
    @ (*) begin
      //$display("current time is %0dns. iCacheReadAddr is %b. iCacheReadData is %b.", $time, iCacheReadAddr, iCacheReadData);
      previCacheReadData = iCacheReadData;
      iCacheReadData = memiCache[iCacheReadAddr>>2];
    end
  end

  //D$ instructions
  always begin
    @(*) begin
      if (dCacheReadEn) begin
            dCacheReadData = memdCache[dCacheAddr];
      end
    end
  end

  always begin
    @(negedge clk) begin
      if (dCacheWriteEn) begin
            memdCache[dCacheAddr] = dCacheWriteData;
      end
    end
  end

  //RF Instructions
  always begin
    @(*) begin
      if (rfReadEn_p0) begin
            //$display("current time is %0dns. rfReadEn_p0 is %b.", $time, rfReadEn_p0);
            rfReadData_p0 = memrfCache[rfReadAddr_p0];
      end
      if (rfReadEn_p1) begin
            //$display("current time is %0dns. rfReadEn_p1 is %b.", $time, rfReadEn_p1);
            rfReadData_p1 = memrfCache[rfReadAddr_p1];
      end
    end
  end
  always begin
    @(negedge clk) begin
      if (rfWriteEn_p0) begin
            memrfCache[rfWriteAddr_p0] = rfWriteData_p0;
      end
    end
  end

  initial begin
    foo = 1'b0;
    #1;
    //$set_gate_level_monitoring("rtl_on");
    //$set_gate_level_monitoring("mda");
    //$set_gate_level_monitoring("rtl_on","sv");
    //$set_gate_level_monitoring("rtl_on","mda");
    #1;
    //$set_toggle_region(top_mipsCore);
    @( posedge triggerStart );
      //$display( "Starting Toggle Collection" );
      //$toggle_start();
      #100000;
      foo = 1'b1;
  end

  //initial begin
  //  #1
  //  @( posedge triggerStart );
  //  #1
  //  @( posedge triggerStop );
  //  $display( "Stopping Toggle Collection" );
  //  //$toggle_stop();
  //  //$toggle_report("top.saif",1.0e-12,top_mipsCore);
  //end




endmodule:top_mipsCore
