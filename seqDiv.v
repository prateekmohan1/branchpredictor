//
//--------------------------------------------------------------------------------
//          THIS FILE WAS AUTOMATICALLY GENERATED BY THE GENESIS2 ENGINE        
//  FOR MORE INFORMATION: OFER SHACHAM (CHIP GENESIS INC / STANFORD VLSI GROUP)
//    !! THIS VERSION OF GENESIS2 IS NOT FOR ANY COMMERCIAL USE !!
//     FOR COMMERCIAL LICENSE CONTACT SHACHAM@ALUMNI.STANFORD.EDU
//--------------------------------------------------------------------------------
//
//  
//	-----------------------------------------------
//	|            Genesis Release Info             |
//	|  $Change: 11904 $ --- $Date: 2013/08/03 $   |
//	-----------------------------------------------
//	
//
//  Source file: /afs/asu.edu/users/p/m/o/pmohan6/EEE591Brunhav/ProjPart4/Submission/primitives/seqDiv.vp
//  Source template: seqDiv
//
// --------------- Begin Pre-Generation Parameters Status Report ---------------
//
//	From 'generate' statement (priority=5):
//
//		---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----
//
//	From Command Line input (priority=4):
//
//		---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----
//
//	From XML input (priority=3):
//
//		---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----
//
//	From Config File input (priority=2):
//
// ---------------- End Pre-Generation Pramameters Status Report ----------------

/////////////
// seqDiv.vp
//
// bitWidth (_GENESIS2_DECLARATION_PRIORITY_) = 32
//

// Use built in module name using Gen2 variable mname

module seqDiv (
	input logic [31:0] den,
	input logic [31:0] num,
	input logic nd_valid,
	output logic nd_ready,

	input logic clk,
	input logic rst,

	output logic [31:0] quo,
	output logic [31:0] rem,
	output logic qr_valid
		);

	//Initialize States
	parameter SIZE = 3;
	parameter S0=3'b000, S1=3'b001, S2=3'b010, S3=3'b011, S4=3'b100, S5=3'b101, S6=3'b110;

	//Counter
	logic [5:0] count_flop;
	
	//Flop
	logic [63:0] den_flop;
	logic [63:0] rem_flop;
	logic [31:0] quo_flop;

	//Input to flops
	logic [63:0] den_d;
	logic [63:0] rem_d;
	logic [31:0] quo_d;
	logic [5:0] count_d;
	logic z_d;

	//Internal wires
	logic [63:0] rem_in;
	logic [31:0] quo_in;
	logic [31:0] quo_sl;
	logic [63:0] rem_sub;

	//Next_State, Current state variable
	logic [SIZE-1:0] state;
	logic [SIZE-1:0] next_state;

	//Clock gate
	logic clk_inp;

	//Select inputs
	logic div_sel, clk_sel, count_sel, rem_sel, comp_sel, quot_sel;

	always_comb begin

		//Mux for input of den
		unique case (div_sel)
		1'b0:begin
			 den_d = {den,32'd0};
		end
		1'b1: begin
			 den_d = den_flop >> 1;
		end
		endcase
	
		//Mux for Clock input
		unique case (clk_sel)
		1'b0: begin
			 clk_inp = clk;
		end
		1'b1: begin
			 clk_inp = clk;
		end
		endcase
	
		//Mux for counter
		unique case (count_sel)
		1'b0: begin
			 count_d = 0;
		end
		1'b1: begin
			 count_d = count_flop + 1;
		end
		endcase
	
		//Mux for rem
		unique case (rem_sel)
		1'b0: begin
			 rem_d = {32'b0,num};
		end
		1'b1: begin
			 rem_d = rem_in;
		end
		endcase
	
		 rem_sub = rem_flop - den_flop;
	
		//Choose value of rem_in
		if (rem_sub[64] != 1'b1) begin
			 comp_sel = 1'b1;
		end
		else begin
			 comp_sel = 1'b0;
		end
	
		//Mux for rem_in
		unique case (comp_sel)
		1'b0: begin
			 rem_in = rem_flop;
			 quo_in = {quo_sl[31:1],1'b0};
		end
		1'b1: begin
			 rem_in = rem_sub;
			 quo_in = {quo_sl[31:1],1'b1};
		end
		endcase
		
		//Mux for count
		unique case (count_sel)
		1'b0: begin
			 count_d = 0;
		end	
		1'b1: begin
			 count_d = count_flop + 1;
		end
		endcase
	
		//Mux for quo
		unique case (quot_sel)
		1'b0: begin
			// quo_d = 0;
			 quo_d = 32'bx;
		end
		1'b1: begin
			 quo_d = quo_in;
		end
		endcase
	
		 quo_sl = quo_flop << 1;

		if (count_flop == 32) begin
			 z_d = 1;
		end
		else begin
			 z_d = 0;
		end

		//Case for output
		unique case (qr_valid)
		1'b0: begin
			 quo = 0;
			 rem = 0;
		end
		1'b1: begin
			 quo = quo_flop;
			 rem = rem_flop[31:0];
		end		
		endcase

		//Case for states
		unique case (state)
		S0: begin
			div_sel = 0;
			rem_sel = 0;
			count_sel = 0;
			quot_sel = 0;
			clk_sel = 0;
			nd_ready = 1;
			if (~nd_valid) begin
				next_state = S0;
			end
			else begin
				next_state = S1;
			end
		end
		S1: begin
			div_sel = 1;
			rem_sel = 1;
			count_sel = 1;
			quot_sel = 1;
			clk_sel = 1;
			nd_ready = 0;
			if (count_flop == 32) begin
				next_state = S0;
			end
			else begin
				next_state = S1;
			end	
		end
		default: begin
			div_sel = 0;
			rem_sel = 0;
			count_sel = 0;
			quot_sel = 0;
			clk_sel = 0;
			nd_ready = 1;
		end
		endcase

	end

	//Flip Flop for den
	dffbW_unq2  my_dffden(.d(den_d),.q(den_flop),.clk(clk_inp),.rst(rst));

	//Flip Flop for rem
	dffbW_unq2  my_dffrem(.d(rem_d),.q(rem_flop),.clk(clk_inp),.rst(rst));

	//Flip Flop for quo 
	dffbW_unq1  my_dffquo(.d(quo_d),.q(quo_flop),.clk(clk_inp),.rst(rst));

	//Flip Flop for count
	dffbW_unq3  my_dffcount(.d(count_d),.q(count_flop),.clk(clk_inp),.rst(rst));

	//Flip Flop for z
	always_ff @ (posedge clk_inp) begin
		qr_valid <= z_d;
	end

	//Flip Flop for state
	always_ff @ (posedge clk) begin
		if (~rst) begin
			state <= S0;
		end
		else begin
			state <= next_state;
		end
	end


//Empty module
endmodule: seqDiv
